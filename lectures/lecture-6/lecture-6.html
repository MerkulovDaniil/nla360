<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture 6: Eigenvalues and eigenvectors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0aff919b4a5b46b9a1aaa4555130091c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" crossorigin="anonymous"></script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Lecture 6: Eigenvalues and eigenvectors">
<meta property="og:description" content="">
<meta property="og:image" content="https://nla360.fmin.xyz/lectures/lecture-6/lecture-6_files/figure-html/cell-4-output-1.png">
<meta property="og:image:height" content="389">
<meta property="og:image:width" content="515">
<meta name="twitter:title" content="Lecture 6: Eigenvalues and eigenvectors">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://nla360.fmin.xyz/lectures/lecture-6/lecture-6_files/figure-html/cell-4-output-1.png">
<meta name="twitter:image-height" content="389">
<meta name="twitter:image-width" content="515">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo.svg" alt="nla360.fmin.xyz" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">üìΩÔ∏è –ü—Ä–æ–µ–∫—Ç—ã</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/MerkulovDaniil/nla360" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
    <a href="https://www.youtube.com/@fmin" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-youtube"></i></a>
    <a href="https://t.me/nla360" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-telegram"></i></a>
    <a href="https://classroom.google.com/c/NzU0NjE2Njg1Mzk3" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-person-workspace"></i></a>
    <a href="https://docs.google.com/spreadsheets/d/116dt8L3jNHEnXSYmqTaldWZ9zmX32kFkw6s-8wdVnrI" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-table"></i></a>
    <a href="https://fmin.xyz" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-gem"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>

<header id="title-block-header">
</header>


<section id="recap-of-the-previous-lecture" class="level2">
<h2 class="anchored" data-anchor-id="recap-of-the-previous-lecture">Recap of the previous lecture</h2>
<ul>
<li>Linear systems</li>
<li>Gaussian elimination</li>
<li>LU decomposition</li>
<li>Condition number as a measure of forward stability of the problem</li>
</ul>
</section>
<section id="today-lecture" class="level2">
<h2 class="anchored" data-anchor-id="today-lecture">Today lecture</h2>
<p>Today we will talk about: - Eigenvectors and their applications (PageRank) - Gershgorin circles - Computing eigenvectors using power method - Schur theorem - Normal matrices</p>
</section>
<section id="what-is-an-eigenvector" class="level2">
<h2 class="anchored" data-anchor-id="what-is-an-eigenvector">What is an eigenvector?</h2>
<ul>
<li><strong>Definition.</strong> A vector <span class="math inline">x \ne 0</span> is called an <strong>eigenvector</strong> of a square matrix <span class="math inline">A</span> if there exists a number <span class="math inline">\lambda</span> such that</li>
</ul>
<p><span class="math display"> Ax = \lambda x. </span></p>
<ul>
<li><p>The number <span class="math inline">\lambda</span> is called an <strong>eigenvalue</strong>. The name <strong>eigenpair</strong> is also used.</p></li>
<li><p>Since <span class="math inline">A - \lambda I</span> should have a non-trivial kernel, eigenvalues are the roots of the characteristic polynomial</p></li>
</ul>
<p><span class="math display"> \det (A - \lambda I) = 0.</span></p>
</section>
<section id="eigendecomposition" class="level2">
<h2 class="anchored" data-anchor-id="eigendecomposition">Eigendecomposition</h2>
<p>If matrix <span class="math inline">A</span> of size <span class="math inline">n\times n</span> has <span class="math inline">n</span> eigenvectors <span class="math inline">s_i</span>, <span class="math inline">i=1,\dots,n</span>:</p>
<p><span class="math display"> As_i = \lambda_i s_i, </span></p>
<p>then this can be written as</p>
<p><span class="math display"> A S = S \Lambda, \quad\text{where}\quad S=(s_1,\dots,s_n), \quad \Lambda = \text{diag}(\lambda_1, \dots, \lambda_n), </span></p>
<p>or equivalently</p>
<p><span class="math display"> A = S\Lambda S^{-1}. </span></p>
<ul>
<li>This is called <strong>eigendecomposition</strong> of a matrix. Matrices that can be represented by their eigendecomposition are called <strong>diagonalizable</strong>.</li>
</ul>
<section id="existence" class="level3">
<h3 class="anchored" data-anchor-id="existence">Existence</h3>
<ul>
<li><p>What classes of matrices are diagonalizable?</p></li>
<li><p>Simple example can be matrices with all different eigenvalues.</p></li>
<li><p>More generally, matrix is diagonalizable iff <strong>algebraic multiplicity</strong> of each eigenvalue (mutiplicity of eigenvalue in the characteristic polynomial) is equal to its <strong>geometric multiplicity</strong> (dimension of eigensubspace).</p></li>
<li><p>For our purposes the most important class of diagonalizable matrices is the class of <strong>normal matrices</strong>:</p></li>
</ul>
<p><span class="math display">AA^* = A^* A.</span></p>
<ul>
<li>You will learn how to prove that normal matrices are diagonalizable after a few slides (Schur decomposition topic).</li>
</ul>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<ul>
<li>You can simply check that, e.g.&nbsp;matrix</li>
</ul>
<p><span class="math display">A = \begin{pmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{pmatrix}</span></p>
<p>has one eigenvalue <span class="math inline">1</span> of multiplicity <span class="math inline">2</span> (since its characteristic polynomial is <span class="math inline">p(\lambda)=(1-\lambda)^2</span>), but only one eigenvector <span class="math inline">\begin{pmatrix} c \\ 0  \end{pmatrix}</span> and hence the matrix is not diagonalizable.</p>
</section>
</section>
</section>
<section id="why-eigenvectors-and-eigenvalues-are-important" class="level2">
<h2 class="anchored" data-anchor-id="why-eigenvectors-and-eigenvalues-are-important">Why eigenvectors and eigenvalues are important?</h2>
<ul>
<li>Eigenvectors are both important auxiliary tools and also play important role in applications.</li>
</ul>
<p>Can you give some examples?</p>
</section>
<section id="applications-of-eigenvalueseigenvectors" class="level2">
<h2 class="anchored" data-anchor-id="applications-of-eigenvalueseigenvectors">Applications of eigenvalues/eigenvectors</h2>
<ul>
<li><strong>Communication theory:</strong> theoretical limit on the amount of information transferred</li>
<li><strong>Designing bridges</strong> (mechanical engineering)</li>
<li><strong>Designing</strong> hifi-audio systems</li>
<li><strong>Quantum chemistry:</strong> all our microworld is governed by the <strong>Schrodinger equation</strong> which is an eigenvalue problem:</li>
</ul>
<p><span class="math display"> H \psi = E \psi, </span></p>
<ul>
<li>Model order reduction of complex systems</li>
<li>Graph analysis (PageRank, graph clustering)</li>
</ul>
</section>
<section id="eigenvalues-are-vibrational-frequencies" class="level2">
<h2 class="anchored" data-anchor-id="eigenvalues-are-vibrational-frequencies">Eigenvalues are vibrational frequencies</h2>
<p>A typical computation of eigenvectors / eigenvectors is for studying</p>
<ul>
<li>Vibrational computations of mechanical structures</li>
<li>Model order reduction of complex systems</li>
</ul>
<div id="cell-12" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> YouTubeVideo </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>YouTubeVideo(<span class="st">"VcCcMZo6J6w"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">

        <iframe width="400" height="300" src="https://www.youtube.com/embed/VcCcMZo6J6w" frameborder="0" allowfullscreen=""></iframe>
        
</div>
</div>
</section>
<section id="google-pagerank" class="level2">
<h2 class="anchored" data-anchor-id="google-pagerank">Google PageRank</h2>
<ul>
<li>One of the most famous eigenvectors computation is the <strong>Google PageRank</strong>.</li>
<li>It is not actively used by Google nowadays, but it was one of the main features in its early stages. The question is how do we rank webpages, which one is important, and which one is not.</li>
<li>All we know about the web is which page refers to which. PageRank is defined by a recursive definition.</li>
<li>Denote by <span class="math inline">p_i</span> the <strong>importance</strong> of the <span class="math inline">i</span>-th page.</li>
<li>Then we define this importance as an average value of all importances of all pages that refer to the current page. It gives us a linear system</li>
</ul>
<p><span class="math display"> p_i = \sum_{j \in N(i)} \frac{p_j}{L(j)}, </span></p>
<p>where <span class="math inline">L(j)</span> is the number of outgoing links on the <span class="math inline">j</span>-th page, <span class="math inline">N(i)</span> are all the neighbours of the <span class="math inline">i</span>-th page. It can be rewritten as</p>
<p><span class="math display"> p = G p, \quad G_{ij} = \frac{1}{L(j)} </span></p>
<p>or as an eigenvalue problem</p>
<p><span class="math display">
   Gp = 1 p,
</span></p>
<p>i.e.&nbsp;the eigenvalue <span class="math inline">1</span> is already known. Note that <span class="math inline">G</span> is <strong>left stochastic</strong>, i.e.&nbsp;its columns sum up to <span class="math inline">1</span>. Check that any left stochastic matrix has maximum eigenvalue equal to <span class="math inline">1</span>.</p>
</section>
<section id="demo" class="level2">
<h2 class="anchored" data-anchor-id="demo">Demo</h2>
<ul>
<li>We can compute PageRank using some Python packages.</li>
<li>We will use <code>networkx</code> package for working with graphs that can be installed using</li>
</ul>
<p><code>conda install networkx</code></p>
<ul>
<li><p>Other packages to work with graphs in Python are <a href="https://igraph.org/">igraph</a> and <a href="https://graph-tool.skewed.de/">graph-tool</a></p></li>
<li><p>They can be useful in your projects</p></li>
<li><p>We will use a simple example of <a href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club">Zachary karate club network</a>.</p></li>
<li><p>This data was manually collected in 1977, and is a classical social network dataset.</p></li>
</ul>
<div id="cell-17" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="5">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>kn <span class="op">=</span> nx.read_gml(<span class="st">'karate.gml'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#nx.write_gml(kn, 'karate2.gml')</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(kn, node_color<span class="op">=</span><span class="st">"red"</span>) <span class="co">#Draw the graph</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lecture-6_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Now we can actually compute the PageRank using the NetworkX built-in function.</li>
<li>We also plot the size of the nodes larger if its PageRank is larger.</li>
</ul>
<div id="cell-19" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pr <span class="op">=</span> nx.algorithms.link_analysis.pagerank(kn)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pr_vector <span class="op">=</span> <span class="bu">list</span>(pr.values())</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>pr_vector <span class="op">=</span> jnp.array(pr_vector) <span class="op">*</span> <span class="dv">3000</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(kn, node_size<span class="op">=</span>pr_vector, node_color<span class="op">=</span><span class="st">"red"</span>, labels<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lecture-6_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="computations-of-eigenvalues" class="level2">
<h2 class="anchored" data-anchor-id="computations-of-eigenvalues">Computations of eigenvalues</h2>
<ul>
<li>How to compute eigenvalues and eigenvectors?</li>
</ul>
<p>There are two types of eigenproblems:</p>
<ul>
<li>full eigenproblem (all eigenvalues &amp; eigenvectors are required)</li>
<li>partial eigenvalues (minimal/maximal eigenvalues, eigenvalues within the specified region are required)</li>
</ul>
</section>
<section id="computation-of-the-eigenvalues-via-characteristic-equations" class="level2">
<h2 class="anchored" data-anchor-id="computation-of-the-eigenvalues-via-characteristic-equations">Computation of the eigenvalues via characteristic equations</h2>
<p>The eigenvalue problem has the form</p>
<p><span class="math display"> Ax = \lambda x, </span></p>
<p>or</p>
<p><span class="math display"> (A - \lambda I) x = 0, </span></p>
<p>therefore matrix <span class="math inline">A - \lambda I</span> has non-trivial kernel and should be singular.</p>
<p>That means, that the <strong>determinant</strong></p>
<p><span class="math display"> p(\lambda) = \det(A - \lambda I) = 0. </span></p>
<ul>
<li>The equation is called <strong>characteristic equations</strong> and is a polynomial of order <span class="math inline">n</span>.</li>
<li>The <span class="math inline">n</span>-degree polynomial has <span class="math inline">n</span> complex roots!</li>
</ul>
</section>
<section id="recall-the-determinant" class="level2">
<h2 class="anchored" data-anchor-id="recall-the-determinant">Recall the determinant</h2>
<p>The determinant of a square matrix <span class="math inline">A</span> is defined as</p>
<p><span class="math display">\det A = \sum_{\sigma \in S_n} \mathrm{sgn}({\sigma})\prod^n_{i=1} a_{i, \sigma_i},</span></p>
<p>where - <span class="math inline">S_n</span> is the set of all <strong>permutations</strong> of the numbers <span class="math inline">1, \ldots, n</span> - <span class="math inline">\mathrm{sgn}</span> is the <strong>signature</strong> of the permutation ( <span class="math inline">(-1)^p</span>, where <span class="math inline">p</span> is the number of transpositions to be made).</p>
</section>
<section id="properties-of-determinant" class="level2">
<h2 class="anchored" data-anchor-id="properties-of-determinant">Properties of determinant</h2>
<p>Determinant has many nice properties:</p>
<p><em>1.</em> <span class="math inline">\det(AB) = \det(A) \det(B)</span></p>
<p><em>2.</em> If we have one row as a sum of two vectors, determinant is a sum of two determinants</p>
<p><em>3.</em> ‚ÄúMinor expansion‚Äù: we can expand determinant through a selected row or column.</p>
<ul>
<li><p>If you do it via <strong>minor expansion</strong>, we get <strong>exponential</strong> complexity in <span class="math inline">n</span>.</p></li>
<li><p>Can we do <span class="math inline">\mathcal{O}(n^3)</span>?</p></li>
</ul>
</section>
<section id="eigenvalues-and-characteristic-equation" class="level2">
<h2 class="anchored" data-anchor-id="eigenvalues-and-characteristic-equation">Eigenvalues and characteristic equation</h2>
<ul>
<li><p>Now we go back to the eigenvalues.</p></li>
<li><p>The characteristic equation can be used to compute the eigenvalues, which leads to <strong>na√Øve</strong> algorithm:</p></li>
</ul>
<p><span class="math display">p(\lambda) = \det(A - \lambda I)</span></p>
<ol type="1">
<li>Compute coefficients of the polynomial</li>
<li>Compute the roots</li>
</ol>
<p><strong>Is this a good idea</strong>?</p>
<p><strong>Give your feedback</strong></p>
<p>We can do a short demo of this</p>
<div id="cell-26" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;fragment&quot;}" data-execution_count="9">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> [[<span class="fl">1.0</span> <span class="op">/</span> (i <span class="op">-</span> j <span class="op">+</span> <span class="fl">0.5</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array(a)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>ev <span class="op">=</span> np.linalg.eigvals(a)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">#There is a special numpy function for chacteristic polynomial</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>cf <span class="op">=</span> np.poly(a)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>ev_roots <span class="op">=</span> np.roots(cf)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">#print('Coefficients of the polynomial:', cf)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">#print('Polynomial roots:', ev_roots)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>plt.scatter(ev_roots.real, ev_roots.imag, marker<span class="op">=</span><span class="st">'x'</span>, label<span class="op">=</span><span class="st">'roots'</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a <span class="op">+</span> <span class="fl">1e-3</span> <span class="op">*</span> np.random.randn(n, n)<span class="co">#jax.random.normal(jax.random.PRNGKey(0,), (n, n))</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>ev_b <span class="op">=</span> np.linalg.eigvals(b)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.scatter(ev_b.real, ev_b.imag, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'Lapack'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co">#plt.scatter(ev_roots.real, ev_roots.imag, marker='o', label='Brute force')</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">'best'</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Real part'</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Imaginary part'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>Text(0, 0.5, 'Imaginary part')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lecture-6_files/figure-html/cell-6-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="morale" class="level3">
<h3 class="anchored" data-anchor-id="morale">Morale</h3>
<ul>
<li>Do not do that, unless you have a reason.</li>
<li>Polynomial rootfinding is very <strong>ill-conditioned</strong> (can be much better, but not with monomials <span class="math inline">\{1,x,x^2,\dots\}</span>!). Note that Gram matrix of monomials</li>
</ul>
<p><span class="math display">h_{ij} = \int_0^1 x^i x^j\, dx = \frac{1}{i+j+1},</span></p>
<p>is the Hilbert matrix, which has exponential decay of singular values. - So, monomials are ‚Äúalmost‚Äù linearly dependent.</p>
</section>
</section>
<section id="gershgorin-circles" class="level2">
<h2 class="anchored" data-anchor-id="gershgorin-circles">Gershgorin circles</h2>
<ul>
<li><p>There is a very interesting theorem that sometimes helps to localize the eigenvalues.</p></li>
<li><p>It is called <strong>Gershgorin theorem</strong>.</p></li>
<li><p>It states that all eigenvalues <span class="math inline">\lambda_i,  i = 1, \ldots, n</span> are located inside the union of <strong>Gershgorin circles</strong> <span class="math inline">C_i</span>, where <span class="math inline">C_i</span> is a disk on the complex plane with center <span class="math inline">a_{ii}</span> and radius</p></li>
</ul>
<p><span class="math display">r_i = \sum_{j \ne i} |a_{ij}|.</span></p>
<ul>
<li>Moreover, if the circles do not intersect they contain only one eigenvalue per circle.</li>
<li>The proof is instructive since it uses the concepts we looked at the previous lectures.</li>
</ul>
</section>
<section id="proof" class="level2">
<h2 class="anchored" data-anchor-id="proof">Proof</h2>
<p>First, we need to show that if the matrix <span class="math inline">A</span> is <strong>strictly diagonally dominant</strong>, i.e.&nbsp;</p>
<p><span class="math display">
   |a_{ii}| &gt; \sum_{j \ne i} |a_{ij}|,
</span> then such matrix is non-singular.</p>
<p>We separate the diagonal part and off-diagonal part, and get</p>
<p><span class="math display">
    A = D + S = D( I + D^{-1}S),
</span></p>
<p>and <span class="math inline">\Vert D^{-1} S\Vert_1 &lt; 1</span>. Therefore, by using the <strong>Neumann series</strong>, the matrix <span class="math inline">I + D^{-1}S</span> is invertible and hence <span class="math inline">A</span> is invertible.</p>
<p>Now the proof follows by contradiction:</p>
<ul>
<li>if any of the eigenvalues lies outside all of the circles, the matrix <span class="math inline">(A - \lambda I)</span> is strictly diagonally dominant</li>
<li>thus it is invertible</li>
<li>that means, that <span class="math inline">(A - \lambda I) x = 0</span> means <span class="math inline">x = 0</span>.</li>
</ul>
</section>
<section id="a-short-demo" class="level2">
<h2 class="anchored" data-anchor-id="a-short-demo">A short demo</h2>
<div id="cell-33" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;slide&quot;}" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> [[<span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="fl">0.5</span>], [<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">10</span>]]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">#a = [[1.0 / (i - j + 0.5) for i in xrange(n)] for j in xrange(n)]</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> jnp.array(a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">#a = np.diag(np.arange(n))</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> a <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> jax.random.normal(jax.random.PRNGKey(<span class="dv">0</span>), (n, n))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">#u = np.random.randn(n, n)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">#a = np.linalg.inv(u).dot(a).dot(u)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>xg <span class="op">=</span> jnp.diag(a).real</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>yg <span class="op">=</span> jnp.diag(a).imag</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>rg <span class="op">=</span> jnp.zeros(n)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>ev <span class="op">=</span> jnp.linalg.eigvals(a)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    rg <span class="op">=</span> jax.ops.index_update(rg, jax.ops.index[i], jnp.<span class="bu">sum</span>(jnp.<span class="bu">abs</span>(a[i, :])) <span class="op">-</span> jnp.<span class="bu">abs</span>(a[i, i]))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    crc <span class="op">=</span> plt.Circle((xg[i], yg[i]), radius<span class="op">=</span>rg[i], fill<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(crc)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>plt.scatter(ev.real, ev.imag, color<span class="op">=</span><span class="st">'r'</span>, label<span class="op">=</span><span class="st">"Eigenvalues"</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Eigenvalues and Gershgorin circles'</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">AttributeError</span>                            Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[7], line 17</span>
<span class="ansi-green-fg ansi-bold">     15</span> ev <span style="color:rgb(98,98,98)">=</span> jnp<span style="color:rgb(98,98,98)">.</span>linalg<span style="color:rgb(98,98,98)">.</span>eigvals(a)
<span class="ansi-green-fg ansi-bold">     16</span> <span style="font-weight:bold;color:rgb(0,135,0)">for</span> i <span style="font-weight:bold;color:rgb(175,0,255)">in</span> <span style="color:rgb(0,135,0)">range</span>(n):
<span class="ansi-green-fg">---&gt; 17</span>     rg <span style="color:rgb(98,98,98)">=</span> <span class="ansi-yellow-bg">jax</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">ops</span><span style="color:rgb(98,98,98)" class="ansi-yellow-bg">.</span><span class="ansi-yellow-bg">index_update</span>(rg, jax<span style="color:rgb(98,98,98)">.</span>ops<span style="color:rgb(98,98,98)">.</span>index[i], jnp<span style="color:rgb(98,98,98)">.</span>sum(jnp<span style="color:rgb(98,98,98)">.</span>abs(a[i, :])) <span style="color:rgb(98,98,98)">-</span> jnp<span style="color:rgb(98,98,98)">.</span>abs(a[i, i]))
<span class="ansi-green-fg ansi-bold">     18</span>     crc <span style="color:rgb(98,98,98)">=</span> plt<span style="color:rgb(98,98,98)">.</span>Circle((xg[i], yg[i]), radius<span style="color:rgb(98,98,98)">=</span>rg[i], fill<span style="color:rgb(98,98,98)">=</span><span style="font-weight:bold;color:rgb(0,135,0)">False</span>)
<span class="ansi-green-fg ansi-bold">     19</span>     ax<span style="color:rgb(98,98,98)">.</span>add_patch(crc)

<span class="ansi-red-fg">AttributeError</span>: module 'jax.ops' has no attribute 'index_update'</pre>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lecture-6_files/figure-html/cell-7-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Note</strong>: There are more complicated figures, like <strong><a href="https://en.wikipedia.org/wiki/Cassini_oval">Cassini ovals</a></strong>, that include the spectrum</p>
<p><span class="math display"> C_{ij} = \{z\in\mathbb{C}: |a_{ii} - z|\cdot |a_{jj} - z|\leq r_i r_j\}, \quad r_i = \sum_{l\not= i} |a_{il}|. </span></p>
</section>
<section id="power-method" class="level2">
<h2 class="anchored" data-anchor-id="power-method">Power method</h2>
<ul>
<li>We are often interested in the computation of the part of the spectrum, like the largest eigenvalues or smallest eigenvalues.</li>
<li>Also it is interesting to note that for the Hermitian matrices <span class="math inline">(A = A^*)</span> the eigenvalues are always real (prove it!).<br>
</li>
<li>A power method is the simplest method for the computation of <strong>the largest eigenvalue in modulus</strong>.</li>
<li>It is also our first example of the <strong>iterative method</strong> and <strong>Krylov method</strong>.</li>
</ul>
</section>
<section id="power-method-1" class="level2">
<h2 class="anchored" data-anchor-id="power-method-1">Power method</h2>
<ul>
<li>The eigenvalue problem</li>
</ul>
<p><span class="math display">Ax = \lambda x, \quad \Vert x \Vert_2 = 1 \ \text{for stability}.</span></p>
<p>can be rewritten as a <strong>fixed-point iteration</strong>. - This iteration is called <strong>power method</strong> and finds the largest in modulus eigenvalue of <span class="math inline">A</span>.</p>
<p>Power method has the form</p>
<p><span class="math display"> x_{k+1} = A x_k, \quad x_{k+1} := \frac{x_{k+1}}{\Vert x_{k+1} \Vert_2}</span></p>
<p>and</p>
<p><span class="math display"> x_{k+1}\to v_1,</span></p>
<p>where <span class="math inline">Av_1 = \lambda_1 v_1</span> and <span class="math inline">\lambda_1</span> is the largest eigenvalue and <span class="math inline">v_1</span> is the corresponding eigenvector.</p>
<ul>
<li>On the <span class="math inline">(k+1)</span>-th iteration approximation to <span class="math inline">\lambda_1</span> can be found as</li>
</ul>
<p><span class="math display"> \lambda^{(k+1)} = (Ax_{k+1}, x_{k+1}), </span></p>
<ul>
<li><p>Note that <span class="math inline">\lambda^{(k+1)}</span> is not required for the <span class="math inline">(k+2)</span>-th iteration, but might be useful to measure error on each iteration: <span class="math inline">\|Ax_{k+1} - \lambda^{(k+1)}x_{k+1}\|</span>.</p></li>
<li><p>The convergence is geometric, but the convergence ratio is <span class="math inline">q^k</span>, where <span class="math inline">q = \left|\frac{\lambda_{2}}{\lambda_{1}}\right| &lt; 1</span>, for <span class="math inline">\lambda_1&gt;\lambda_2\geq\dots\geq \lambda_n</span> and <span class="math inline">k</span> is the number of iteration.</p></li>
<li><p>It means, the convergence can be artitrary small. To prove it, it is sufficient to consider a <span class="math inline">2 \times 2</span> diagonal matrix.</p></li>
</ul>
</section>
<section id="convergence-analysis-for-aa" class="level2">
<h2 class="anchored" data-anchor-id="convergence-analysis-for-aa">Convergence analysis for <span class="math inline">A=A^*</span></h2>
<p>Let‚Äôs have a more precise look at the power method when <span class="math inline">A</span> is Hermitian. In two slides you will learn that every Hermitian matrix is diagonalizable. Therefore, there exists orthonormal basis of eigenvectors <span class="math inline">v_1,\dots,v_n</span> such that <span class="math inline">Av_i = \lambda_i v_i</span>. Let us decompose <span class="math inline">x_0</span> into a sum of <span class="math inline">v_i</span> with coefficients <span class="math inline">c_i</span>:</p>
<p><span class="math display"> x_0 = c_1 v_1 + \dots + c_n v_n. </span></p>
<p>Since <span class="math inline">v_i</span> are eigenvectors, we have</p>
<p><span class="math display">
\begin{split}
x_1 &amp;= \frac{Ax_0}{\|Ax_0\|} = \frac{c_1 \lambda_1 v_1 + \dots + c_n \lambda_n v_n}{\|c_1 \lambda_1 v_1 + \dots + c_n \lambda_n v_n \|}  \\
&amp;\vdots\\
x_k &amp;= \frac{Ax_{k-1}}{\|Ax_{k-1}\|} = \frac{c_1 \lambda_1^k v_1 + \dots + c_n \lambda_n^k v_n}{\|c_1 \lambda_1^k v_1 + \dots + c_n \lambda_n^k v_n \|}
\end{split}
</span></p>
<p>Now you see, that</p>
<p><span class="math display">
x_k = \frac{c_1}{|c_1|}\left(\frac{\lambda_1}{|\lambda_1|}\right)^k\frac{ v_1 + \frac{c_2}{c_1}\frac{\lambda_2^k}{\lambda_1^k}v_2 + \dots + \frac{c_n}{c_1}\frac{\lambda_n^k}{\lambda_1^k}v_n}{\left\|v_1 + \frac{c_2}{c_1}\frac{\lambda_2^k}{\lambda_1^k}v_2 + \dots + \frac{c_n}{c_1}\frac{\lambda_n^k}{\lambda_1^k}v_n\right\|},
</span></p>
<p>which converges to <span class="math inline">v_1</span> since <span class="math inline">\left| \frac{c_1}{|c_1|}\left(\frac{\lambda_1}{|\lambda_1|}\right)^k\right| = 1</span> and <span class="math inline">\left(\frac{\lambda_2}{\lambda_1}\right)^k \to 0</span> if <span class="math inline">|\lambda_2|&lt;|\lambda_1|</span>.</p>
</section>
<section id="things-to-remember-about-the-power-method" class="level2">
<h2 class="anchored" data-anchor-id="things-to-remember-about-the-power-method">Things to remember about the power method</h2>
<ul>
<li>Power method gives estimate of the largest eigenvalue in modulus or spectral radius of the given matrix</li>
<li>One step requires one matrix-by-vector product. If the matrix allows for an <span class="math inline">\mathcal{O}(n)</span> matvec (for example, it is sparse), then power method is tractable for larger <span class="math inline">n</span>.</li>
<li>Convergence can be slow</li>
<li>If only a rough estimate is needed, only a few iterations are sufficient</li>
<li>The solution vector is in the <strong>Krylov subspace</strong> <span class="math inline">\{x_0, Ax_0,\dots,A^{k}x_0\}</span> and has the form <span class="math inline">\mu A^k x_0</span>, where <span class="math inline">\mu</span> is the normalization constant.</li>
</ul>
</section>
<section id="matrix-decomposition-the-schur-form" class="level1">
<h1>Matrix decomposition: the Schur form</h1>
<p>There is one class of matrices when eigenvalues can be found easily: <strong>triangular matrices</strong></p>
<p><span class="math display">
  A = \begin{pmatrix}
   \lambda_1 &amp; * &amp; * \\
   0 &amp; \lambda_2 &amp; * \\
   0 &amp; 0 &amp; \lambda_3 \\
  \end{pmatrix}.
</span></p>
<p>The eigenvalues of <span class="math inline">A</span> are <span class="math inline">\lambda_1, \lambda_2, \lambda_3</span>. Why?</p>
<p>Because the determinant is</p>
<p><span class="math display">
   \det(A - \lambda I) = (\lambda - \lambda_1) (\lambda - \lambda_2) (\lambda - \lambda_3).
</span></p>
<ul>
<li>Thus, computing the eigenvalues of triangular matrices is easy. Now, the unitary matrices come to help.</li>
<li>Let <span class="math inline">U</span> be a unitary matrix, i.e.&nbsp;<span class="math inline">U^* U = I</span>. Then</li>
</ul>
<p><span class="math display">
   \det(A - \lambda I) = \det(U (U^* A U - \lambda I) U^*) = \det(UU^*) \det(U^* A U - \lambda I) = \det(U^* A U - \lambda I),
</span></p>
<p>where we have used the famous multiplicativity property of the determinant, <span class="math inline">\det(AB) = \det(A) \det(B)</span>. - It means, that the matrices <span class="math inline">U^* A U</span> and <span class="math inline">A</span> have the same characteristic polynomials, and the same eigenvalues.</p>
<ul>
<li><p>If we manage to make <span class="math inline">U^* A U = T</span> where <span class="math inline">T</span> is <strong>upper triangular</strong>, then we are done.</p></li>
<li><p>Multplying from the left and the right by <span class="math inline">U</span> and <span class="math inline">U^*</span> respectively, we get the desired decomposition:</p></li>
</ul>
<p><span class="math display"> A = U T U^*. </span></p>
<p>This is the celebrated <strong>Schur decomposition</strong>. - Recall that unitary matrices imply stability, thus the eigenvalues are computed very accurately.</p>
<p>The Schur decomposition shows why we need matrix decompositions: it represents a matrix into a product of three matrices with a convenient structure.</p>
<section id="schur-theorem" class="level2">
<h2 class="anchored" data-anchor-id="schur-theorem">Schur theorem</h2>
<p><strong>Theorem:</strong> Every <span class="math inline">A \in \mathbb{C}^{n \times n}</span> matrix can be represented in the Schur form <span class="math inline">A = UTU^*</span>, where <span class="math inline">U</span> is unitary and <span class="math inline">T</span> is upper triangular.</p>
<p><strong>Sketch of the proof</strong>. 1. Every matrix has at least <span class="math inline">1</span> non-zero eigenvector (take a root of characteristic polynomial, <span class="math inline">(A-\lambda I)</span> is singular, has non-trivial nullspace). Let</p>
<p><span class="math display">Av_1 = \lambda_1 v_1, \quad \Vert v_1 \Vert_2 = 1</span></p>
<ol start="2" type="1">
<li>Let <span class="math inline">U_1 = [v_1,v_2,\dots,v_n]</span>, where <span class="math inline">v_2,\dots, v_n</span> are any vectors othogonal to <span class="math inline">v_1</span>. Then</li>
</ol>
<p><span class="math display"> U^*_1 A U_1 = \begin{pmatrix} \lambda_1 &amp; *  \\ 0 &amp; A_2  \end{pmatrix}, </span></p>
<p>where <span class="math inline">A_2</span> is an <span class="math inline">(n-1) \times (n-1)</span> matrix. This is called <strong>block triangular form</strong>. We can now work with <span class="math inline">A_2</span> only and so on.</p>
<p><strong>Note</strong>: Since we need eigenvectors in this proof, this proof is not a practical algorithm.</p>
</section>
<section id="application-of-the-schur-theorem" class="level2">
<h2 class="anchored" data-anchor-id="application-of-the-schur-theorem">Application of the Schur theorem</h2>
<ul>
<li><p>Important application of the Schur theorem: <strong>normal matrices</strong>.</p></li>
<li><p><strong>Definition.</strong> Matrix <span class="math inline">A</span> is called <strong>normal matrix</strong>, if</p></li>
</ul>
<p><span class="math display"> AA^* = A^* A. </span></p>
<p><strong>Q:</strong> Examples of normal matrices?</p>
<p>Examples: Hermitian matrices, unitary matrices.</p>
</section>
<section id="normal-matrices" class="level2">
<h2 class="anchored" data-anchor-id="normal-matrices">Normal matrices</h2>
<p><strong>Theorem</strong>: <span class="math inline">A</span> is a <strong>normal matrix</strong>, iff <span class="math inline">A = U \Lambda U^*</span>, where <span class="math inline">U</span> is unitary and <span class="math inline">\Lambda</span> is diagonal.</p>
<p><strong>Sketch of the proof:</strong> - One way is straightforward (if the decomposition holds, the matrix is normal).<br>
- The other is more complicated. Consider the Schur form of the matrix <span class="math inline">A</span>. Then <span class="math inline">AA^* = A^*A</span> means <span class="math inline">TT^* = T^* T</span>.<br>
- By looking at the elements we immediately see, that the only upper triangular matrix <span class="math inline">T</span> that satisfies <span class="math inline">TT^* = T^* T</span> is a diagonal matrix!</p>
<section id="important-consequence" class="level4">
<h4 class="anchored" data-anchor-id="important-consequence">Important consequence</h4>
<p>Therefore, every normal matrix is <strong>unitary diagonalizable</strong>, which means that it can be diagonalized by unitary matrix <span class="math inline">U</span>.</p>
<p>In other words every normal matrix has orthogonal basis of eigenvectors.</p>
</section>
</section>
<section id="how-we-compute-the-schur-decomposition" class="level2">
<h2 class="anchored" data-anchor-id="how-we-compute-the-schur-decomposition">How we compute the Schur decomposition?</h2>
<ul>
<li><p>Everything is fine, but how we compute the Schur form?</p></li>
<li><p>This will be covered in the next lecture.</p></li>
</ul>
</section>
<section id="variational-principle-for-eigenvalues" class="level2">
<h2 class="anchored" data-anchor-id="variational-principle-for-eigenvalues">Variational principle for eigenvalues</h2>
<ul>
<li>In many cases, minimal/maximal eigenvalues are needed</li>
<li>Then, if <span class="math inline">A</span> is a Hermitian matrix, the <strong>Rayleigh quotient</strong> is defined as</li>
</ul>
<p><span class="math display">R_A(x) = \frac{(Ax, x)}{(x, x)},</span></p>
<p>and the maximal eigenvalue is the maximum of <span class="math inline">R_A(x)</span>, and the minimal eigenvalue is the minimal of <span class="math inline">R_A(x)</span>.</p>
<ul>
<li><p>Thus, we can use optimization method to find these <strong>extreme eigenvalues</strong>.</p></li>
<li><p>This approach will be crucial in the case of partial eigenvalue problem for large sparse matrices</p></li>
</ul>
<p>Now, ‚Äúadvanced‚Äù concept.</p>
</section>
<section id="spectrum-and-pseudospectrum" class="level2">
<h2 class="anchored" data-anchor-id="spectrum-and-pseudospectrum">Spectrum and pseudospectrum</h2>
<ul>
<li><p>For linear dynamical systems given by the matrix <span class="math inline">A</span>, spectrum can tell a lot about the system (i.e.&nbsp;stability, ‚Ä¶)</p></li>
<li><p>However, for <strong>non-normal matrices</strong>, spectrum can be unstable with respect to small perturbations.</p></li>
<li><p>In order to measure such perturbation, the notion of <strong>pseudospectrum</strong> has been developed.</p></li>
</ul>
</section>
<section id="pseudospectrum" class="level2">
<h2 class="anchored" data-anchor-id="pseudospectrum">Pseudospectrum</h2>
<p>We consider the union of all possible eigenvalues of all perturbations of the matrix <span class="math inline">A</span>.</p>
<p><span class="math display">\Lambda_{\epsilon}(A) = \{ \lambda \in \mathbb{C}: \exists E, x \ne 0: (A + E) x = \lambda x, \quad \Vert E \Vert_2 \leq \epsilon. \}</span></p>
<ul>
<li>For small <span class="math inline">E</span> and normal <span class="math inline">A</span> these will be circules around eigenvalues, for non-normal matrices, the structure can be much different. More details: http://www.cs.ox.ac.uk/pseudospectra/</li>
</ul>
<p><img src="pseudospectrum.gif" width="700"></p>
</section>
<section id="summary-of-todays-lecture" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-todays-lecture">Summary of todays lecture</h2>
<ul>
<li>Eigenvalues, eigenvectors</li>
<li>Gershgorin theorem</li>
<li>Power method</li>
<li>Schur theorem</li>
<li>Normal matrices</li>
<li>Some advanced topics</li>
</ul>
</section>
<section id="next-lecture" class="level2">
<h2 class="anchored" data-anchor-id="next-lecture">Next lecture</h2>
<ul>
<li>Review of the considered matrix decompositions</li>
<li>Practical way to compute QR decomposition</li>
<li>Almost practical method for computing eigenvalues and eigenvectors</li>
</ul>
<section id="questions" class="level3">
<h3 class="anchored" data-anchor-id="questions">Questions?</h3>
<div id="cell-55" class="cell" data-slideshow="{&quot;slide_type&quot;:&quot;skip&quot;}">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> css_styling():</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    styles <span class="op">=</span> <span class="bu">open</span>(<span class="st">"./styles/custom.css"</span>, <span class="st">"r"</span>).read()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HTML(styles)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>css_styling()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nla360\.fmin\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions"><ul><li><a href="https://github.dev/MerkulovDaniil/nla360/blob/main/lectures/lecture-6/lecture-6.ipynb" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>